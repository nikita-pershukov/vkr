\section{Разработка архитектуры и выбор инструментария}
\label{sec:tools}

Картинки с разными уровнями погружений и т.д. в новую архитектуру с пояснениями

% \clearpage
% \textbf{!!! Переписать}
% 
% Выбранный стек технологий является одним из основных на текущий момент для разработки и развертывания приложений во всем мире. Но отдельного упоминания заслуживают причины, которые привели к этой ситуации:
% 
% \subsubsection{Docker}
% 
% \textbf{Docker} - это программное обеспечения для автоматизации развертывания и управления приложениями в средах с поддрежкой контейнеризации.\textit{Но что это значит?} Для понимания этого инструмента необходимо посмотреть, что было до него:
% \begin{itemize}
%     \item Монолитная эра:
%         \begin{itemize}
%             \item Приложения монолитные;
%             \item Куча зависимостей;
%             \item Долгая разработка до релиза;
%             \item Все инстансы известны по именам;
%             \item Использование виртуализации:
%                 \begin{itemize}
%                     \item Один сервер - несколько \textit{VM};
%                     \item \textit{Resource Management};
%                     \item Изоляция окружений.
%                 \end{itemize}
%         \end{itemize}
%         Соответсвенно использовались \textit{VM}:
%         \begin{itemize}
%             \item VMWare;
%             \item Microsoft Hyper-V;
%             \item VirtualBox;
%             \item Qemu.
%         \end{itemize}
%         Подход был такой: один большой сервер делили на несколько виртуальных машин. Это давало полную изоляцию, но недостатками были:
%         \begin{itemize}
%             \item Hypervisor;
%             \item Большие образы;
%             \item И как следствие больших образов с разным ПО - медленное управление \textit{VM}.
%         \end{itemize}
%     \item На смену им пришла виртуализация на уровне ядра:
%         \begin{itemize}
%             \item OpenVZ;
%             \item Systemd-nspawn;
%             \item LXC.
%         \end{itemize}
%         Но остались прежние проблемы:
%         \begin{itemize}
%             \item Большие образы с \textit{OS} с большим количеством ПО.
%             \item Нет стандарта упаковки и доставки.
%             \item \textit{DLL Hell}.
%         \end{itemize}
%     \item Но далее пришли контейнеры. Разница между \textit{VM} и контейнером:
%         \begin{itemize}
%             \item Виртуальная машина подразумевает виртуализацию железа для запуска гостевой ОС.
%             \item Контейнер использует ядро хостовой ОС.
%             \item В \textit{VM} может работать любая ОС.
%             \item в контейнере может работать только GNU/Linux (с недавних пор и Windows).
%             \item \textit{VM} хороша для изоляции.
%             \item Контейнеры не подходят для изоляции.
%         \end{itemize}
%         %В итоге мы приходим к ситуации, изображенной на \imref{container-vs-vm.png}:
%         %\includeimg{container-vs-vm.png}{width=1\linewidth}{Сравнение \textit{VM} и контейнеров}
%         \newpage
%         Способ реализации контейнеризации:
%         \begin{itemize}
%             \item \textit{Namespaces}:
%                 \begin{itemize}
%                     \item \textit{PID};
%                     \item \textit{Networking};
%                     \item \textit{Mount};
%                     \item \textit{User};
%                     \item etc.
%                 \end{itemize}
%             \item Control Groups:
%                 \begin{itemize}
%                     \item Memory;
%                     \item CPU;
%                     \item Block \textit{I/O};
%                     \item \textit{Network};
%                     \item etc.
%                 \end{itemize}
%         \end{itemize}
%         В итоге получается следующая логика:
%         \begin{itemize}
%             \item Один процесс - один контейнер.
%             \item Все зависимости в контейнере.
%             \item Чем меньше образ контейнера - тем лучше.
%             \item Инстансы становятся эфемерными.
%         \end{itemize}
%         И в 2014-2015 годах пришел расцвет \textit{Docker}, который:
%         \begin{itemize}
%             \item Меняет философию подхода к разработке.
%             \item Стандартизует упаковку приложения.
%             \item Решает вопрос зависимостей.
%             \item Гарантирует воспроизводимость.
%             \item Обеспечивает минимум дополнительных средств для использования.
%         \end{itemize}
% \end{itemize}
% По своей сути \textit{Docker} - это обертка или надстройка над \textit{Namespaces} и \textit{Cgroup}, которые существуют как родные инстументы изоляции в \textit{OS} GNU/Linux, которые упрощают запуск процесса в изолированном пространстве.
% 
% \subsubsection{Kubernetes}
% 
% \textbf{Kubernetes} - оркестратор контейнеров. \textit{Зачем он нужен?} У нас уже есть \textit{Docker}, который удобен для разработки и развертки приложений, особенно в формате микросервисов. Его можно сравнить с фурой, на которую грузят один контейнер и которая его везет. Но этого зачастую недостаточно. Есть \textit{Docker} Compose, который может запускать несколько контейнеров, взаимодействующих друг с другом и внешним миром. Его можно сравнить с паровозом, который может везти несколько контейнеров. В свое время \textit{Kubernetes} правильно сравнивать с морским портом, где находится огромное количество контейнеров, которые распределены по разным складам, перемещаются между складами при необходимости, чинит их при поломке. То есть, вне зависимости от масштаба и количества контейнеров, \textit{Kubernetes} позволяет их гибко разварачивать, управлять, перемещать и масштабировать.
% Его основные преимущества:
% \begin{itemize}
%     \item \textit{Immutable} - неизменямая структура. Эта идея уже была реализована в \textit{Docker} касательно \textit{Docker} Image - он не изменяется в процессе работы. В \textit{Kubernetes} же неизменна вся структура.
%     \item \textit{Self-healing} - каждый компонент отвечает за свою часть инфрастуктуры и постоянно поддерживает ее в актуальном состоянии.Например, при падении одного из нескольких серверов те контейнеры, что были запущены на упавшем сервере, будут запущены на одном из оставшимся в живых сервере.
%     \item \textit{Declarative} - описание не того, что надо сделать (императивный подход), а как должен выглядеть итоговый результать. В случае \textit{Kubernetes} все управление происходит посредством \textit{Yaml} манифестов.
%     \item Каждый компонент инфраструктуры независим от других и полагается на их \textit{SLA}.
% \end{itemize}
% По своей сути \textit{Kubernetes} - это надстройка над \textit{Docker}, которая позволяет управлять огромным количеством контейнеров, распределенных на разных серверах.
% 
% \subsubsection{Helm}
% 
% \textbf{Helm} - инструмент, который помогает управлять приложениями в \textit{Kubernetes}. \textit{Но зачем нам еще помощь, когда уже есть Docker и Kubernetes, которые сильно упрощают жизнь?} Для этого надо посмотреть на логику работы с приложением. Допустим есть приложение, которое состоит из нескольких \textit{YAML} манифестов для \textit{Kubernetes}, которые уже настроены, и их можно применить с помощью \textit{kubectl apply -f path/to/dir}. Вроде все хорошо. Но ведь приложение растет, оно может начать занимать сотни \textit{YAML} манифестов, а помнить все переменные окружения и прочие вещи станет достаточно сложно. Самый простой пример: замена \textit{labels} и \textit{selector} во всех манифеста одного микросервиса. Есть варианты использовать \textit{sed} или \textit{ansible}, и они решат проблему запуска чего-то нового. Но что делать, если что-то пошло не так? То есть как откатить на предыдущую версию или как контроллировать процесс релиза? И тут на помощь приходит \textit{Helm}. Он при применении создает артефакт с указанной версии и сохраняет его где-то. И в случае, если что-то пошло не так, возможно взять сохраненный предыдущий артефакт и запустить из него стабильную версию. При этом создатели \textit{Helm} позиционируют его как "пакетный менеджер", с помощью которого можно скачать, установить, удалить приложение вместе с его зависимостями. Он, как и сам \textit{Kubernetes}, декларативный. Также, он умеет не просто применить \textit{YAML} манифесты, но и отследить процесс запуска всего необходимого, а в случае ошибки, откатиться назад автоматически.
