\section{Виды архитектур инфраструктуры и приложений в ней}
\label{sec:history}

На текущий момент существует множество решений со стороны архитектуры инфраструктуры и, как следствие, приложений в ней. Для выбора конкретного решения под вышеуказанные \textbf{Указать цели выше} цели необходимо рассмотреть основные из них. Далее они будут описаны по хронологии появления.

\begin{enumerate}
    \item Монолитная эра. Ей свойственны следующие аспекты:
        \begin{itemize}
            \item Приложения монолитные.
            \item Куча зависимостей.
            \item Долгая разработка до релиза.
            \item Все инстансы известны по именам.
                \Define{Инстанс}{экземлпяр объекта}
            \item Использование виртуализации. Это означает:
                \begin{itemize}
                    \item Один сервер -- несколько VM \cite{wiki:vm}.
                        \Abbrev{VM}{virtual machine (виртуальная машина)}
                        \Define{Виртуальная машина}{программная и/или аппаратная система, эмулирующая аппаратное обеспечение некоторой платформы (target — целевая, или гостевая платформа) и исполняющая программы для target-платформы на host-платформе (host — хост-платформа, платформа-хозяин) или виртуализирующая некоторую платформу и создающая на ней среды, изолирующие друг от друга программы и даже операционные системы \cite{wiki:vm}}
                    \item Resource Management.
                        \Define{Resource management}{управление и ограничение ресурсов машины}
                    \item Изоляция окружений.
                \end{itemize}
        \end{itemize}

        Соответсвенно использовались VM:
        \begin{itemize}
            \item VMWare.
            \item Microsoft Hyper-V.
            \item VirtualBox.
            \item Qemu.
        \end{itemize}

        Подход был следующий: один большой сервер делили на несколько виртуальных машин. Это давало полную изоляцию, но недостатками были:
        \begin{itemize}
            \item Hypervisor \cite{wiki:hypervisor}.
                \Define{Гипервизор}{программа или аппаратная схема, обеспечивающая или позволяющая одновременное, параллельное выполнение нескольких операционных систем на одном и том же хост-компьютере \cite{wiki:hypervisor}}
            \item Большие образы.
            \item Как следствие больших образов с разным ПО -- медленное управление VM.
        \end{itemize}
    \item На смену им пришла виртуализация на уровне ядра с помощью следующих инструментов:
        \begin{itemize}
            \item OpenVZ.
            \item Systemd-nspawn.
            \item LXC.
        \end{itemize}

        Но остались прежние проблемы:
        \begin{itemize}
            \item Большие образы с OS с большим количеством ПО.
                \Abbrev{OS или ОС}{операционная система}
                \Abbrev{ПО}{программное обеспечение}
            \item Нет стандарта упаковки и доставки.
            \item DLL Hell \cite{dick2018dll}.
                \Define{DLL Hell}{сбой, возникающий, когда одна часть программного обеспечения ведет себя не так, как ожидалось второй частью программного обеспечения, что в некотором роде "зависит" от действия первого \cite{dick2018dll}}
        \end{itemize}
    \item Но далее пришли контейнеры. Разница между VM и контейнером:
        \begin{itemize}
            \item Виртуальная машина подразумевает виртуализацию железа для запуска гостевой ОС.
            \item Контейнер использует ядро хостовой ОС.
            \item В VM может работать любая ОС.
            \item В контейнере может работать только GNU/Linux (с недавних пор и Windows).
            \item VM хороша для изоляции.
            \item Контейнеры не подходят для изоляции.
        \end{itemize}

        В итоге мы приходим к ситуации, изображенной на \imref{container-vs-vm}:
        \includeimg{container-vs-vm}{width=1\linewidth}{Сравнение VM и контейнеров}

        Способ реализации контейнеризации:
        \begin{itemize}
            \item Namespaces:
                \Define{Namespaces}{пространства имен}
                \begin{itemize}
                    \item PID.
                        \Abbrev{PID}{Proccess ID}
                        \Define{Process ID}{идентификатор процесса}
                    \item Networking.
                        \Define{Networking или network}{сеть}
                    \item Mount.
                        \Define{Mount}{монтирование, например дисков как директорий. Способ подключения различных хранителей данных в OS GNU/Linux}
                    \item User;
                        \Define{User}{пользователь}
                \end{itemize}
            \item Control Groups:
                \Abbrev{Cgroup}{control group}
                \Define{Control group}{управление (контроль) групп}
                \begin{itemize}
                    \item Memory.
                        \Define{Memory}{память}.
                    \item CPU
                        \Abbrev{CPU}{central processing unit}
                        \Define{Central processing unit}{процессор}
                    \item Block I/O;
                        \Abbrev{I/O}{input and output}
                        \Define{Block input and output}{обращение на считывание и запись с хранителей данных}
                    \item Network;
                \end{itemize}
        \end{itemize}

        В итоге получается следующая логика:
        \begin{itemize}
            \item Один процесс -- один контейнер.
            \item Все зависимости в контейнере.
            \item Чем меньше образ контейнера -- тем лучше.
                \Define{Image или образ контейнера}{архив файловой системы, который используется для запуска контейнера из него}
            \item Инстансы становятся эфемерными.
        \end{itemize}

        И в 2014-2015 годах пришел расцвет Docker \cite{демидова2019использование}, который:
        \Define{Docker}{программное обеспечение для автоматизации развертывания и управления приложениями в среде виртуализации на уровне операционной системы \cite{демидова2019использование}}
        \begin{itemize}
            \item Меняет философию подхода к разработке.
            \item Стандартизует упаковку приложения.
            \item Решает вопрос зависимостей.
            \item Гарантирует воспроизводимость.
            \item Обеспечивает минимум дополнительных средств для использования.
        \end{itemize}
\end{enumerate}
